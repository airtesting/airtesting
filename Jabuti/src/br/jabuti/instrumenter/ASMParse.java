/*  Copyright 2003  Auri Marcelo Rizzo Vicenzi, Marcio Eduardo Delamaro, 			    Jose Carlos Maldonado

    This file is part of Jabuti.

    Jabuti is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as 
    published by the Free Software Foundation, either version 3 of the      
    License, or (at your option) any later version.

    Jabuti is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Jabuti.  If not, see <http://www.gnu.org/licenses/>.
*/


/* Generated By:JavaCC: Do not edit this line. ASMParse.java */
package br.jabuti.instrumenter;

import java.io.InputStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import org.apache.bcel.classfile.Field;
import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ANEWARRAY;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.BIPUSH;
import org.apache.bcel.generic.BREAKPOINT;
import org.apache.bcel.generic.BranchInstruction;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ClassGen;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.DCONST;
import org.apache.bcel.generic.DLOAD;
import org.apache.bcel.generic.FCONST;
import org.apache.bcel.generic.FLOAD;
import org.apache.bcel.generic.FSTORE;
import org.apache.bcel.generic.FieldGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.GETSTATIC;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.GOTO_W;
import org.apache.bcel.generic.ICONST;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFGE;
import org.apache.bcel.generic.IFGT;
import org.apache.bcel.generic.IFLE;
import org.apache.bcel.generic.IFLT;
import org.apache.bcel.generic.IFNE;
import org.apache.bcel.generic.IFNONNULL;
import org.apache.bcel.generic.IFNULL;
import org.apache.bcel.generic.IF_ACMPEQ;
import org.apache.bcel.generic.IF_ACMPNE;
import org.apache.bcel.generic.IF_ICMPEQ;
import org.apache.bcel.generic.IF_ICMPGE;
import org.apache.bcel.generic.IF_ICMPGT;
import org.apache.bcel.generic.IF_ICMPLE;
import org.apache.bcel.generic.IF_ICMPLT;
import org.apache.bcel.generic.IF_ICMPNE;
import org.apache.bcel.generic.IINC;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.IMPDEP1;
import org.apache.bcel.generic.IMPDEP2;
import org.apache.bcel.generic.INSTANCEOF;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionConstants;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.JSR;
import org.apache.bcel.generic.JSR_W;
import org.apache.bcel.generic.LCONST;
import org.apache.bcel.generic.LDC;
import org.apache.bcel.generic.LDC2_W;
import org.apache.bcel.generic.LDC_W;
import org.apache.bcel.generic.LLOAD;
import org.apache.bcel.generic.LOOKUPSWITCH;
import org.apache.bcel.generic.LSTORE;
import org.apache.bcel.generic.MULTIANEWARRAY;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.NEWARRAY;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.bcel.generic.PUTSTATIC;
import org.apache.bcel.generic.RET;
import org.apache.bcel.generic.SIPUSH;
import org.apache.bcel.generic.Select;
import org.apache.bcel.generic.TABLESWITCH;
import org.apache.bcel.generic.Type;

import br.jabuti.util.Debug;


public class ASMParse implements ASMParseConstants {
ConstantPoolGen cpg;
ClassGen clg;
MethodGen meth;

    public ASMParse(InputStream is, MethodGen m, ClassGen cg)
    {
        this(is);
        cpg = m.getConstantPool();
        clg = cg;
        meth = m;
    }

  final public InstructionList ASMProg() throws ParseException {
InstructionList v = new InstructionList();
Hashtable l2inst = new Hashtable(),
          hand2l = new Hashtable();
Instruction ins = null;
String s = null;
Token t;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
      case AALOAD:
      case AASTORE:
      case ACONST_NULL:
      case ALOAD:
      case ALOAD_0:
      case ALOAD_1:
      case ALOAD_2:
      case ANEWARRAY:
      case ARETURN:
      case ARRAYLENGTH:
      case ASTORE:
      case ASTORE_0:
      case ASTORE_1:
      case ASTORE_2:
      case ATHROW:
      case BALOAD:
      case BASTORE:
      case BIPUSH:
      case BREAKPOINT:
      case CALOAD:
      case CASTORE:
      case CHECKCAST:
      case D2F:
      case D2I:
      case D2L:
      case DADD:
      case DALOAD:
      case DASTORE:
      case DCMPG:
      case DCMPL:
      case DCONST:
      case DCONST_0:
      case DCONST_1:
      case DDIV:
      case DLOAD:
      case DMUL:
      case DNEG:
      case DREM:
      case DRETURN:
      case DSUB:
      case DUP:
      case DUP_X1:
      case DUP_X2:
      case DUP2:
      case DUP2_X1:
      case DUP2_X2:
      case F2D:
      case F2I:
      case F2L:
      case FADD:
      case FALOAD:
      case FASTORE:
      case FCMPG:
      case FCMPL:
      case FCONST:
      case FCONST_0:
      case FCONST_1:
      case FCONST_2:
      case FDIV:
      case FLOAD:
      case FMUL:
      case FNEG:
      case FREM:
      case FRETURN:
      case FSTORE:
      case FSUB:
      case GETFIELD:
      case GETSTATIC:
      case GOTO:
      case GOTO_W:
      case I2B:
      case I2C:
      case I2D:
      case I2F:
      case I2L:
      case I2S:
      case IADD:
      case IALOAD:
      case IAND:
      case IASTORE:
      case ICONST:
      case ICONST_0:
      case ICONST_1:
      case ICONST_2:
      case ICONST_3:
      case ICONST_4:
      case ICONST_5:
      case ICONST_M1:
      case IDIV:
      case IF_ACMPEQ:
      case IF_ACMPNE:
      case IF_ICMPEQ:
      case IF_ICMPGE:
      case IF_ICMPGT:
      case IF_ICMPLE:
      case IF_ICMPLT:
      case IF_ICMPNE:
      case IFEQ:
      case IFGE:
      case IFGT:
      case IFLE:
      case IFLT:
      case IFNE:
      case IFNONNULL:
      case IFNULL:
      case IINC:
      case ILOAD:
      case ILOAD_0:
      case ILOAD_1:
      case ILOAD_2:
      case IMPDEP_1:
      case IMPDEP_2:
      case IMUL:
      case INEG:
      case INSTANCEOF:
      case INVOKEINTERFACE:
      case INVOKESPECIAL:
      case INVOKESTATIC:
      case INVOKEVIRTUAL:
      case IOR:
      case IREM:
      case IRETURN:
      case ISHL:
      case ISHR:
      case ISTORE:
      case ISTORE_0:
      case ISTORE_1:
      case ISTORE_2:
      case ISUB:
      case IUSHR:
      case IXOR:
      case JSR:
      case JSR_W:
      case L2D:
      case L2F:
      case L2I:
      case LADD:
      case LALOAD:
      case LAND:
      case LASTORE:
      case LCMP:
      case LCONST:
      case LCONST_0:
      case LCONST_1:
      case LDC:
      case LDC_W:
      case LDC2_W:
      case LDIV:
      case LLOAD:
      case LMUL:
      case LNEG:
      case LOOKUPSWITCH:
      case LOR:
      case LREM:
      case LRETURN:
      case LSHL:
      case LSHR:
      case LSTORE:
      case LSUB:
      case LUSHR:
      case LXOR:
      case MONITORENTER:
      case MONITOREXIT:
      case MULTIANEWARRAY:
      case NEW:
      case NEWARRAY:
      case NOP:
      case POP:
      case POP2:
      case PUTFIELD:
      case PUTSTATIC:
      case RET:
      case RETURN:
      case SALOAD:
      case SASTORE:
      case SIPUSH:
      case SWAP:
      case TABLESWITCH:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AALOAD:
      case AASTORE:
      case ACONST_NULL:
      case ALOAD:
      case ALOAD_0:
      case ALOAD_1:
      case ALOAD_2:
      case ANEWARRAY:
      case ARETURN:
      case ARRAYLENGTH:
      case ASTORE:
      case ASTORE_0:
      case ASTORE_1:
      case ASTORE_2:
      case ATHROW:
      case BALOAD:
      case BASTORE:
      case BIPUSH:
      case BREAKPOINT:
      case CALOAD:
      case CASTORE:
      case CHECKCAST:
      case D2F:
      case D2I:
      case D2L:
      case DADD:
      case DALOAD:
      case DASTORE:
      case DCMPG:
      case DCMPL:
      case DCONST:
      case DCONST_0:
      case DCONST_1:
      case DDIV:
      case DLOAD:
      case DMUL:
      case DNEG:
      case DREM:
      case DRETURN:
      case DSUB:
      case DUP:
      case DUP_X1:
      case DUP_X2:
      case DUP2:
      case DUP2_X1:
      case DUP2_X2:
      case F2D:
      case F2I:
      case F2L:
      case FADD:
      case FALOAD:
      case FASTORE:
      case FCMPG:
      case FCMPL:
      case FCONST:
      case FCONST_0:
      case FCONST_1:
      case FCONST_2:
      case FDIV:
      case FLOAD:
      case FMUL:
      case FNEG:
      case FREM:
      case FRETURN:
      case FSTORE:
      case FSUB:
      case GETFIELD:
      case GETSTATIC:
      case GOTO:
      case GOTO_W:
      case I2B:
      case I2C:
      case I2D:
      case I2F:
      case I2L:
      case I2S:
      case IADD:
      case IALOAD:
      case IAND:
      case IASTORE:
      case ICONST:
      case ICONST_0:
      case ICONST_1:
      case ICONST_2:
      case ICONST_3:
      case ICONST_4:
      case ICONST_5:
      case ICONST_M1:
      case IDIV:
      case IF_ACMPEQ:
      case IF_ACMPNE:
      case IF_ICMPEQ:
      case IF_ICMPGE:
      case IF_ICMPGT:
      case IF_ICMPLE:
      case IF_ICMPLT:
      case IF_ICMPNE:
      case IFEQ:
      case IFGE:
      case IFGT:
      case IFLE:
      case IFLT:
      case IFNE:
      case IFNONNULL:
      case IFNULL:
      case IINC:
      case ILOAD:
      case ILOAD_0:
      case ILOAD_1:
      case ILOAD_2:
      case IMPDEP_1:
      case IMPDEP_2:
      case IMUL:
      case INEG:
      case INSTANCEOF:
      case INVOKEINTERFACE:
      case INVOKESPECIAL:
      case INVOKESTATIC:
      case INVOKEVIRTUAL:
      case IOR:
      case IREM:
      case IRETURN:
      case ISHL:
      case ISHR:
      case ISTORE:
      case ISTORE_0:
      case ISTORE_1:
      case ISTORE_2:
      case ISUB:
      case IUSHR:
      case IXOR:
      case JSR:
      case JSR_W:
      case L2D:
      case L2F:
      case L2I:
      case LADD:
      case LALOAD:
      case LAND:
      case LASTORE:
      case LCMP:
      case LCONST:
      case LCONST_0:
      case LCONST_1:
      case LDC:
      case LDC_W:
      case LDC2_W:
      case LDIV:
      case LLOAD:
      case LMUL:
      case LNEG:
      case LOOKUPSWITCH:
      case LOR:
      case LREM:
      case LRETURN:
      case LSHL:
      case LSHR:
      case LSTORE:
      case LSUB:
      case LUSHR:
      case LXOR:
      case MONITORENTER:
      case MONITOREXIT:
      case MULTIANEWARRAY:
      case NEW:
      case NEWARRAY:
      case NOP:
      case POP:
      case POP2:
      case PUTFIELD:
      case PUTSTATIC:
      case RET:
      case RETURN:
      case SALOAD:
      case SASTORE:
      case SIPUSH:
      case SWAP:
      case TABLESWITCH:
      case IDENTIFIER:
          s = null;
        if (jj_2_1(2)) {
          t = jj_consume_token(IDENTIFIER);
          jj_consume_token(COLON);
                                                 s = t.image;
        } else {
          ;
        }
        ins = ASMInstruction();
                 InstructionHandle ih;
                 if ( ins instanceof FakeBranchInstruction )
                 {
                    FakeBranchInstruction fbi = (FakeBranchInstruction) ins;
                    ih = v.append(fbi.getRealInstruction());
                    String[] p = fbi.getTargets();
                    hand2l.put(ih, p);
                 }
                 else
                    ih = v.append(ins);
                 if (s != null)
                    l2inst.put(s, ih);
        break;
      case DOT:
        directive();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
            Enumeration en = hand2l.keys();
            while (en.hasMoreElements())
            {
                InstructionHandle ih = (InstructionHandle) en.nextElement();
                String[] p = (String []) hand2l.get(ih);
                InstructionHandle targ = (InstructionHandle) l2inst.get(p[0]);
                if ( targ == null )
                    {if (true) throw new ParseException("Label " + p[0] + " not found");}
                ((BranchInstruction) ih.getInstruction()).setTarget(targ);
                if (ih.getInstruction() instanceof Select)
                {
                    for (int i = 1; i < p.length; i++)
                    {
                        targ = (InstructionHandle) l2inst.get(p[i]);
                        if ( targ == null )
                            {if (true) throw new ParseException("Label " + p[i] + " not found");}
                        ((Select) ih.getInstruction()).setTarget(i-1, targ);
                    }
                }
            }
            {if (true) return v;}
    throw new Error("Missing return statement in function");
  }

  final public Instruction ASMInstruction() throws ParseException {
Instruction ins = null;
ins = UnlabeledInstruction();
        {if (true) return ins;}
    throw new Error("Missing return statement in function");
  }

  final public Instruction UnlabeledInstruction() throws ParseException {
Vector v = new Vector(),
       v1 = new Vector();
Token t1, t2, t3;
String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AALOAD:
      jj_consume_token(AALOAD);
               {if (true) return InstructionConstants.AALOAD  ;}
      break;
    case AASTORE:
      jj_consume_token(AASTORE);
                {if (true) return InstructionConstants.AASTORE  ;}
      break;
    case ACONST_NULL:
      jj_consume_token(ACONST_NULL);
                    {if (true) return InstructionConstants.ACONST_NULL  ;}
      break;
    case ALOAD:
      jj_consume_token(ALOAD);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new ALOAD(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid ALOAD argument: " + t1.image);}
            }
      break;
    case ALOAD_0:
      jj_consume_token(ALOAD_0);
                {if (true) return InstructionConstants.ALOAD_0  ;}
      break;
    case ALOAD_1:
      jj_consume_token(ALOAD_1);
                {if (true) return InstructionConstants.ALOAD_1  ;}
      break;
    case ALOAD_2:
      jj_consume_token(ALOAD_2);
                {if (true) return InstructionConstants.ALOAD_2  ;}
      break;
    case ANEWARRAY:
      jj_consume_token(ANEWARRAY);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new ANEWARRAY(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid ANEWARRAY argument: " + t1.image);}
            }
      break;
    case ARETURN:
      jj_consume_token(ARETURN);
                 {if (true) return InstructionConstants.ARETURN  ;}
      break;
    case ARRAYLENGTH:
      jj_consume_token(ARRAYLENGTH);
                    {if (true) return InstructionConstants.ARRAYLENGTH  ;}
      break;
    case ASTORE:
      jj_consume_token(ASTORE);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new ASTORE(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid ASTORE argument: " + t1.image);}
            }
      break;
    case ASTORE_0:
      jj_consume_token(ASTORE_0);
                 {if (true) return InstructionConstants.ASTORE_0  ;}
      break;
    case ASTORE_1:
      jj_consume_token(ASTORE_1);
                 {if (true) return InstructionConstants.ASTORE_1  ;}
      break;
    case ASTORE_2:
      jj_consume_token(ASTORE_2);
                  {if (true) return InstructionConstants.ASTORE_2  ;}
      break;
    case ATHROW:
      jj_consume_token(ATHROW);
                {if (true) return InstructionConstants.ATHROW  ;}
      break;
    case BALOAD:
      jj_consume_token(BALOAD);
                {if (true) return InstructionConstants.BALOAD  ;}
      break;
    case BASTORE:
      jj_consume_token(BASTORE);
                 {if (true) return InstructionConstants.BASTORE  ;}
      break;
    case BIPUSH:
      jj_consume_token(BIPUSH);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                byte k = Byte.parseByte(t1.image);
                {if (true) return new BIPUSH(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid BIPUSH argument: " + t1.image);}
            }
      break;
    case BREAKPOINT:
      jj_consume_token(BREAKPOINT);
                   {if (true) return new BREAKPOINT()  ;}
      break;
    case CALOAD:
      jj_consume_token(CALOAD);
                {if (true) return InstructionConstants.CALOAD  ;}
      break;
    case CASTORE:
      jj_consume_token(CASTORE);
                 {if (true) return InstructionConstants.CASTORE  ;}
      break;
    case CHECKCAST:
      jj_consume_token(CHECKCAST);
      s = classname();
            {
            int k = cpg.addClass(s);
            {if (true) return new CHECKCAST(k);}
            }
      break;
    case D2F:
      jj_consume_token(D2F);
             {if (true) return InstructionConstants.D2F  ;}
      break;
    case D2I:
      jj_consume_token(D2I);
             {if (true) return InstructionConstants.D2I  ;}
      break;
    case D2L:
      jj_consume_token(D2L);
             {if (true) return InstructionConstants.D2L  ;}
      break;
    case DADD:
      jj_consume_token(DADD);
              {if (true) return InstructionConstants.DADD  ;}
      break;
    case DALOAD:
      jj_consume_token(DALOAD);
                {if (true) return InstructionConstants.DALOAD  ;}
      break;
    case DASTORE:
      jj_consume_token(DASTORE);
                 {if (true) return InstructionConstants.DASTORE  ;}
      break;
    case DCMPG:
      jj_consume_token(DCMPG);
               {if (true) return InstructionConstants.DCMPG  ;}
      break;
    case DCMPL:
      jj_consume_token(DCMPL);
               {if (true) return InstructionConstants.DCMPL  ;}
      break;
    case DCONST:
      jj_consume_token(DCONST);
      t1 = jj_consume_token(FIXED_POINT_LITERAL);
            try
            {
                double k = Double.parseDouble(t1.image);
                {if (true) return new DCONST(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid DCONST argument: " + t1.image);}
            }
      break;
    case DCONST_0:
      jj_consume_token(DCONST_0);
                  {if (true) return InstructionConstants.DCONST_0  ;}
      break;
    case DCONST_1:
      jj_consume_token(DCONST_1);
                  {if (true) return InstructionConstants.DCONST_1  ;}
      break;
    case DDIV:
      jj_consume_token(DDIV);
              {if (true) return InstructionConstants.DDIV  ;}
      break;
    case DLOAD:
      jj_consume_token(DLOAD);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new DLOAD(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid DLOAD argument: " + t1.image);}
            }
      break;
    case DMUL:
      jj_consume_token(DMUL);
              {if (true) return InstructionConstants.DMUL  ;}
      break;
    case DNEG:
      jj_consume_token(DNEG);
              {if (true) return InstructionConstants.DNEG  ;}
      break;
    case DREM:
      jj_consume_token(DREM);
              {if (true) return InstructionConstants.DREM  ;}
      break;
    case DRETURN:
      jj_consume_token(DRETURN);
                 {if (true) return InstructionConstants.DRETURN  ;}
      break;
    case DSUB:
      jj_consume_token(DSUB);
              {if (true) return InstructionConstants.DSUB  ;}
      break;
    case DUP:
      jj_consume_token(DUP);
             {if (true) return InstructionConstants.DUP  ;}
      break;
    case DUP_X1:
      jj_consume_token(DUP_X1);
                {if (true) return InstructionConstants.DUP_X1  ;}
      break;
    case DUP_X2:
      jj_consume_token(DUP_X2);
                {if (true) return InstructionConstants.DUP_X2  ;}
      break;
    case DUP2:
      jj_consume_token(DUP2);
              {if (true) return InstructionConstants.DUP2  ;}
      break;
    case DUP2_X1:
      jj_consume_token(DUP2_X1);
                 {if (true) return InstructionConstants.DUP2_X1  ;}
      break;
    case DUP2_X2:
      jj_consume_token(DUP2_X2);
                 {if (true) return InstructionConstants.DUP2_X2  ;}
      break;
    case F2D:
      jj_consume_token(F2D);
             {if (true) return InstructionConstants.F2D  ;}
      break;
    case F2I:
      jj_consume_token(F2I);
             {if (true) return InstructionConstants.F2I  ;}
      break;
    case F2L:
      jj_consume_token(F2L);
             {if (true) return InstructionConstants.F2L  ;}
      break;
    case FADD:
      jj_consume_token(FADD);
              {if (true) return InstructionConstants.FADD  ;}
      break;
    case FALOAD:
      jj_consume_token(FALOAD);
                {if (true) return InstructionConstants.FALOAD  ;}
      break;
    case FASTORE:
      jj_consume_token(FASTORE);
                 {if (true) return InstructionConstants.FASTORE  ;}
      break;
    case FCMPG:
      jj_consume_token(FCMPG);
              {if (true) return InstructionConstants.FCMPG  ;}
      break;
    case FCMPL:
      jj_consume_token(FCMPL);
               {if (true) return InstructionConstants.FCMPL  ;}
      break;
    case FCONST:
      jj_consume_token(FCONST);
      t1 = jj_consume_token(FIXED_POINT_LITERAL);
            try
            {
                float k = Float.parseFloat(t1.image);
                {if (true) return new FCONST(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid FCONST argument: " + t1.image);}
            }
      break;
    case FCONST_0:
      jj_consume_token(FCONST_0);
                  {if (true) return InstructionConstants.FCONST_0  ;}
      break;
    case FCONST_1:
      jj_consume_token(FCONST_1);
                  {if (true) return InstructionConstants.FCONST_1  ;}
      break;
    case FCONST_2:
      jj_consume_token(FCONST_2);
                  {if (true) return InstructionConstants.FCONST_2  ;}
      break;
    case FDIV:
      jj_consume_token(FDIV);
              {if (true) return InstructionConstants.FDIV  ;}
      break;
    case FLOAD:
      jj_consume_token(FLOAD);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new FLOAD(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid FLOAD argument: " + t1.image);}
            }
      break;
    case FMUL:
      jj_consume_token(FMUL);
              {if (true) return InstructionConstants.FMUL  ;}
      break;
    case FNEG:
      jj_consume_token(FNEG);
              {if (true) return InstructionConstants.FNEG  ;}
      break;
    case FREM:
      jj_consume_token(FREM);
              {if (true) return InstructionConstants.FREM  ;}
      break;
    case FRETURN:
      jj_consume_token(FRETURN);
                 {if (true) return InstructionConstants.FRETURN  ;}
      break;
    case FSTORE:
      jj_consume_token(FSTORE);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new FSTORE(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid FSTORE argument: " + t1.image);}
            }
      break;
    case FSUB:
      jj_consume_token(FSUB);
              {if (true) return InstructionConstants.FSUB  ;}
      break;
    case GETFIELD:
      jj_consume_token(GETFIELD);
      s = classname();
      t1 = jj_consume_token(IDENTIFIER);
      t2 = jj_consume_token(STRING_LITERAL);
            {
            String p = t2.image.substring(1, t2.image.length()-1);
            int k = cpg.addFieldref(s, t1.image, p);
            {if (true) return new GETFIELD(k);}
            }
      break;
    case GETSTATIC:
      jj_consume_token(GETSTATIC);
      s = classname();
      t1 = jj_consume_token(IDENTIFIER);
      t2 = jj_consume_token(STRING_LITERAL);
            {
            String p = t2.image.substring(1, t2.image.length()-1);
            int k = cpg.addFieldref(s, t1.image, p);
            Debug.D(p);
            {if (true) return new GETSTATIC(k);}
            }
      break;
    case GOTO:
      jj_consume_token(GOTO);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            GOTO gt = new GOTO(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case GOTO_W:
      jj_consume_token(GOTO_W);
      t1 = jj_consume_token(IDENTIFIER);
            v.add(t1.image);
            GOTO_W gtw = new GOTO_W(null);
            {if (true) return new FakeBranchInstruction(gtw, v);}
      break;
    case I2B:
      jj_consume_token(I2B);
             {if (true) return InstructionConstants.I2B  ;}
      break;
    case I2C:
      jj_consume_token(I2C);
             {if (true) return InstructionConstants.I2C  ;}
      break;
    case I2D:
      jj_consume_token(I2D);
             {if (true) return InstructionConstants.I2D  ;}
      break;
    case I2F:
      jj_consume_token(I2F);
             {if (true) return InstructionConstants.I2F  ;}
      break;
    case I2L:
      jj_consume_token(I2L);
             {if (true) return InstructionConstants.I2L  ;}
      break;
    case I2S:
      jj_consume_token(I2S);
             {if (true) return InstructionConstants.I2S  ;}
      break;
    case IADD:
      jj_consume_token(IADD);
              {if (true) return InstructionConstants.IADD  ;}
      break;
    case IALOAD:
      jj_consume_token(IALOAD);
                {if (true) return InstructionConstants.IALOAD  ;}
      break;
    case IAND:
      jj_consume_token(IAND);
             {if (true) return InstructionConstants.IAND  ;}
      break;
    case IASTORE:
      jj_consume_token(IASTORE);
                 {if (true) return InstructionConstants.IASTORE  ;}
      break;
    case ICONST:
      jj_consume_token(ICONST);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new ICONST(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid ICONST argument: " + t1.image);}
            }
      break;
    case ICONST_0:
      jj_consume_token(ICONST_0);
                  {if (true) return InstructionConstants.ICONST_0  ;}
      break;
    case ICONST_1:
      jj_consume_token(ICONST_1);
                  {if (true) return InstructionConstants.ICONST_1  ;}
      break;
    case ICONST_2:
      jj_consume_token(ICONST_2);
                  {if (true) return InstructionConstants.ICONST_2  ;}
      break;
    case ICONST_3:
      jj_consume_token(ICONST_3);
                  {if (true) return InstructionConstants.ICONST_3  ;}
      break;
    case ICONST_4:
      jj_consume_token(ICONST_4);
                  {if (true) return InstructionConstants.ICONST_4  ;}
      break;
    case ICONST_5:
      jj_consume_token(ICONST_5);
                  {if (true) return InstructionConstants.ICONST_5  ;}
      break;
    case ICONST_M1:
      jj_consume_token(ICONST_M1);
                   {if (true) return InstructionConstants.ICONST_M1  ;}
      break;
    case IDIV:
      jj_consume_token(IDIV);
              {if (true) return InstructionConstants.IDIV  ;}
      break;
    case IF_ACMPEQ:
      jj_consume_token(IF_ACMPEQ);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IF_ACMPEQ gt = new IF_ACMPEQ(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IF_ACMPNE:
      jj_consume_token(IF_ACMPNE);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IF_ACMPNE gt = new IF_ACMPNE(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IF_ICMPEQ:
      jj_consume_token(IF_ICMPEQ);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IF_ICMPEQ gt = new IF_ICMPEQ(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IF_ICMPGE:
      jj_consume_token(IF_ICMPGE);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IF_ICMPGE gt = new IF_ICMPGE(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IF_ICMPGT:
      jj_consume_token(IF_ICMPGT);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IF_ICMPGT gt = new IF_ICMPGT(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IF_ICMPLE:
      jj_consume_token(IF_ICMPLE);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IF_ICMPLE gt = new IF_ICMPLE(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IF_ICMPLT:
      jj_consume_token(IF_ICMPLT);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IF_ICMPLT gt = new IF_ICMPLT(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IF_ICMPNE:
      jj_consume_token(IF_ICMPNE);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IF_ICMPNE gt = new IF_ICMPNE(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IFEQ:
      jj_consume_token(IFEQ);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IFEQ gt = new IFEQ(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IFGE:
      jj_consume_token(IFGE);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IFGE gt = new IFGE(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IFGT:
      jj_consume_token(IFGT);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IFGT gt = new IFGT(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IFLE:
      jj_consume_token(IFLE);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IFLE gt = new IFLE(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IFLT:
      jj_consume_token(IFLT);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IFLT gt = new IFLT(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IFNE:
      jj_consume_token(IFNE);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IFNE gt = new IFNE(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IFNONNULL:
      jj_consume_token(IFNONNULL);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IFNONNULL gt = new IFNONNULL(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IFNULL:
      jj_consume_token(IFNULL);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            IFNULL gt = new IFNULL(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case IINC:
      jj_consume_token(IINC);
      t1 = jj_consume_token(INTEGER_LITERAL);
      t2 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                int j = Integer.parseInt(t2.image);
                {if (true) return new IINC(k, j);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid IINC argument");}
            }
      break;
    case ILOAD:
      jj_consume_token(ILOAD);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new ILOAD(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid ILOAD argument: " + t1.image);}
            }
      break;
    case ILOAD_0:
      jj_consume_token(ILOAD_0);
                 {if (true) return InstructionConstants.ILOAD_0  ;}
      break;
    case ILOAD_1:
      jj_consume_token(ILOAD_1);
                 {if (true) return InstructionConstants.ILOAD_1  ;}
      break;
    case ILOAD_2:
      jj_consume_token(ILOAD_2);
                 {if (true) return InstructionConstants.ILOAD_2  ;}
      break;
    case IMPDEP_1:
      jj_consume_token(IMPDEP_1);
                  {if (true) return new IMPDEP1();}
      break;
    case IMPDEP_2:
      jj_consume_token(IMPDEP_2);
                  {if (true) return new IMPDEP2();}
      break;
    case IMUL:
      jj_consume_token(IMUL);
              {if (true) return InstructionConstants.IMUL  ;}
      break;
    case INEG:
      jj_consume_token(INEG);
              {if (true) return InstructionConstants.INEG  ;}
      break;
    case INSTANCEOF:
      jj_consume_token(INSTANCEOF);
      s = classname();
            {
            int k = cpg.addClass(s);
            {if (true) return new INSTANCEOF(k);}
            }
      break;
    case INVOKEINTERFACE:
      jj_consume_token(INVOKEINTERFACE);
      s = classname();
      t1 = jj_consume_token(IDENTIFIER);
      t2 = jj_consume_token(STRING_LITERAL);
      t3 = jj_consume_token(INTEGER_LITERAL);
            {
            int j;
            try
            {
                j = Integer.parseInt(t3.image);
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid INVOKEINTERFACE argument: " + t3.image);}
            }
            String p = t2.image.substring(1, t2.image.length()-1);
            int k = cpg.addInterfaceMethodref(s, t1.image, p);
            {if (true) return new INVOKEINTERFACE(k, j);}
            }
      break;
    case INVOKESPECIAL:
      jj_consume_token(INVOKESPECIAL);
      s = classname();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        t1 = jj_consume_token(IDENTIFIER);
        break;
      case INIT:
        t1 = jj_consume_token(INIT);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = jj_consume_token(STRING_LITERAL);
            {
            String p = t2.image.substring(1, t2.image.length()-1);
            int k = cpg.addMethodref(s, t1.image, p);
            {if (true) return new INVOKESPECIAL(k);}
            }
      break;
    case INVOKESTATIC:
      jj_consume_token(INVOKESTATIC);
      s = classname();
      t1 = jj_consume_token(IDENTIFIER);
      t2 = jj_consume_token(STRING_LITERAL);
            {
            String p = t2.image.substring(1, t2.image.length()-1);
            int k = cpg.addMethodref(s, t1.image, p);
            {if (true) return new INVOKESTATIC(k);}
            }
      break;
    case INVOKEVIRTUAL:
      jj_consume_token(INVOKEVIRTUAL);
      s = classname();
      t1 = jj_consume_token(IDENTIFIER);
      t2 = jj_consume_token(STRING_LITERAL);
            {
            String p = t2.image.substring(1, t2.image.length()-1);
            int k = cpg.addMethodref(s, t1.image, p);
            {if (true) return new INVOKEVIRTUAL(k);}
            }
      break;
    case IOR:
      jj_consume_token(IOR);
            {if (true) return InstructionConstants.IOR  ;}
      break;
    case IREM:
      jj_consume_token(IREM);
              {if (true) return InstructionConstants.IREM  ;}
      break;
    case IRETURN:
      jj_consume_token(IRETURN);
                 {if (true) return InstructionConstants.IRETURN  ;}
      break;
    case ISHL:
      jj_consume_token(ISHL);
              {if (true) return InstructionConstants.ISHL  ;}
      break;
    case ISHR:
      jj_consume_token(ISHR);
              {if (true) return InstructionConstants.ISHR  ;}
      break;
    case ISTORE:
      jj_consume_token(ISTORE);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new ISTORE(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid ISTORE argument: " + t1.image);}
            }
      break;
    case ISTORE_0:
      jj_consume_token(ISTORE_0);
                  {if (true) return InstructionConstants.ISTORE_0  ;}
      break;
    case ISTORE_1:
      jj_consume_token(ISTORE_1);
                  {if (true) return InstructionConstants.ISTORE_1  ;}
      break;
    case ISTORE_2:
      jj_consume_token(ISTORE_2);
                  {if (true) return InstructionConstants.ISTORE_2  ;}
      break;
    case ISUB:
      jj_consume_token(ISUB);
              {if (true) return InstructionConstants.ISUB  ;}
      break;
    case IUSHR:
      jj_consume_token(IUSHR);
               {if (true) return InstructionConstants.IUSHR  ;}
      break;
    case IXOR:
      jj_consume_token(IXOR);
              {if (true) return InstructionConstants.IXOR  ;}
      break;
    case JSR:
      jj_consume_token(JSR);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            JSR gt = new JSR(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case JSR_W:
      jj_consume_token(JSR_W);
      t1 = jj_consume_token(IDENTIFIER);
            {
            v.add(t1.image);
            JSR_W gt = new JSR_W(null);
            {if (true) return new FakeBranchInstruction(gt, v);}
            }
      break;
    case L2D:
      jj_consume_token(L2D);
             {if (true) return InstructionConstants.L2D  ;}
      break;
    case L2F:
      jj_consume_token(L2F);
             {if (true) return InstructionConstants.L2F  ;}
      break;
    case L2I:
      jj_consume_token(L2I);
             {if (true) return InstructionConstants.L2I  ;}
      break;
    case LADD:
      jj_consume_token(LADD);
              {if (true) return InstructionConstants.LADD  ;}
      break;
    case LALOAD:
      jj_consume_token(LALOAD);
                {if (true) return InstructionConstants.LALOAD  ;}
      break;
    case LAND:
      jj_consume_token(LAND);
              {if (true) return InstructionConstants.LAND  ;}
      break;
    case LASTORE:
      jj_consume_token(LASTORE);
                 {if (true) return InstructionConstants.LASTORE  ;}
      break;
    case LCMP:
      jj_consume_token(LCMP);
              {if (true) return InstructionConstants.LCMP  ;}
      break;
    case LCONST:
      jj_consume_token(LCONST);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                long k = Long.parseLong(t1.image);
                {if (true) return new LCONST(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid LCONST argument: " + t1.image);}
            }
      break;
    case LCONST_0:
      jj_consume_token(LCONST_0);
                  {if (true) return InstructionConstants.LCONST_0  ;}
      break;
    case LCONST_1:
      jj_consume_token(LCONST_1);
                  {if (true) return InstructionConstants.LCONST_1  ;}
      break;
    case LDC:
      jj_consume_token(LDC);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t1 = jj_consume_token(INTEGER_LITERAL);
        break;
      case STRING_LITERAL:
        t1 = jj_consume_token(STRING_LITERAL);
        break;
      case FIXED_POINT_LITERAL:
        t1 = jj_consume_token(FIXED_POINT_LITERAL);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            {
            int k = -1;
            if (t1.kind == STRING_LITERAL)
            {
                k = cpg.addString(t1.image.substring(1,t1.image.length()-1));
            }
            else
            if (t1.kind == FIXED_POINT_LITERAL)
            {
                try
                {
                    float f = Float.parseFloat(t1.image);
                    k = cpg.addFloat(f);
                }
                catch (NumberFormatException e)
                {
                    {if (true) throw new ParseException("Invalid LDC float argument: " + t1.image);}
                }
            }
            else
            {
                try
                {
                    int f = Integer.parseInt(t1.image);
                    k = cpg.addInteger(f);
                }
                catch (NumberFormatException e)
                {
                    {if (true) throw new ParseException("Invalid LDC integer argument: " + t1.image);}
                }
            }
            {if (true) return new LDC(k);}
            }
      break;
    case LDC_W:
      jj_consume_token(LDC_W);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t1 = jj_consume_token(INTEGER_LITERAL);
        break;
      case STRING_LITERAL:
        t1 = jj_consume_token(STRING_LITERAL);
        break;
      case FIXED_POINT_LITERAL:
        t1 = jj_consume_token(FIXED_POINT_LITERAL);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            {
            int k = -1;
            if (t1.kind == STRING_LITERAL)
            {
                k = cpg.addString(t1.image.substring(1,t1.image.length()-1));
            }
            else
            if (t1.kind == FIXED_POINT_LITERAL)
            {
                try
                {
                    float f = Float.parseFloat(t1.image);
                    k = cpg.addFloat(f);
                }
                catch (NumberFormatException e)
                {
                    {if (true) throw new ParseException("Invalid LDC_W float argument: " + t1.image);}
                }
            }
            else
            {
                try
                {
                    int f = Integer.parseInt(t1.image);
                    k = cpg.addInteger(f);
                }
                catch (NumberFormatException e)
                {
                    {if (true) throw new ParseException("Invalid LDC_W integer argument: " + t1.image);}
                }
            }
            {if (true) return new LDC_W(k);}
            }
      break;
    case LDC2_W:
      jj_consume_token(LDC2_W);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t1 = jj_consume_token(INTEGER_LITERAL);
        break;
      case STRING_LITERAL:
        t1 = jj_consume_token(STRING_LITERAL);
        break;
      case FIXED_POINT_LITERAL:
        t1 = jj_consume_token(FIXED_POINT_LITERAL);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            {
            int k = -1;
            if (t1.kind == STRING_LITERAL)
            {
                k = cpg.addString(t1.image.substring(1,t1.image.length()-1));
            }
            else
            if (t1.kind == FIXED_POINT_LITERAL)
            {
                try
                {
                    float f = Float.parseFloat(t1.image);
                    k = cpg.addFloat(f);
                }
                catch (NumberFormatException e)
                {
                    {if (true) throw new ParseException("Invalid LDC_W float argument: " + t1.image);}
                }
            }
            else
            {
                try
                {
                    int f = Integer.parseInt(t1.image);
                    k = cpg.addInteger(f);
                }
                catch (NumberFormatException e)
                {
                    {if (true) throw new ParseException("Invalid LDC_W integer argument: " + t1.image);}
                }
            }
            {if (true) return new LDC2_W(k);}
            }
      break;
    case LDIV:
      jj_consume_token(LDIV);
              {if (true) return InstructionConstants.LDIV  ;}
      break;
    case LLOAD:
      jj_consume_token(LLOAD);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new LLOAD(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid LLOAD argument: " + t1.image);}
            }
      break;
    case LMUL:
      jj_consume_token(LMUL);
              {if (true) return InstructionConstants.LMUL  ;}
      break;
    case LNEG:
      jj_consume_token(LNEG);
              {if (true) return InstructionConstants.LNEG  ;}
      break;
    case LOOKUPSWITCH:
      jj_consume_token(LOOKUPSWITCH);
      t2 = jj_consume_token(INTEGER_LITERAL);
      t3 = jj_consume_token(INTEGER_LITERAL);
                                v = new Vector();
      label_2:
      while (true) {
        t1 = jj_consume_token(IDENTIFIER);
                                v.add(t1.image);
        if (getToken(1).kind == IDENTIFIER && getToken(2).kind != COLON) {
          ;
        } else {
          break label_2;
        }
      }
            {
            int f = 0, to = 0;
            try
            {
                f = Integer.parseInt(t2.image);
                to = Integer.parseInt(t3.image);
                if (to - f + 2 != v.size())
                    {if (true) throw new NumberFormatException();}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid LOOKUPSWITCH arguments" + v.size() +
                    " " + (to-f+2));}
            }
            int[] match = new int[to - f + 1];
            for (int i = 0; i < match.length; i++)
            {
                match[i] = f + i;
            }
            LOOKUPSWITCH ls = new LOOKUPSWITCH(match, new InstructionHandle[match.length], null);
            {if (true) return new FakeBranchInstruction(ls, v);}
            }
      break;
    case LOR:
      jj_consume_token(LOR);
             {if (true) return InstructionConstants.LOR  ;}
      break;
    case LREM:
      jj_consume_token(LREM);
              {if (true) return InstructionConstants.LREM  ;}
      break;
    case LRETURN:
      jj_consume_token(LRETURN);
                 {if (true) return InstructionConstants.LRETURN  ;}
      break;
    case LSHL:
      jj_consume_token(LSHL);
              {if (true) return InstructionConstants.LSHL  ;}
      break;
    case LSHR:
      jj_consume_token(LSHR);
              {if (true) return InstructionConstants.LSHR  ;}
      break;
    case LSTORE:
      jj_consume_token(LSTORE);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                {if (true) return new LSTORE(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid LSTORE argument: " + t1.image);}
            }
      break;
    case LSUB:
      jj_consume_token(LSUB);
              {if (true) return InstructionConstants.LSUB  ;}
      break;
    case LUSHR:
      jj_consume_token(LUSHR);
               {if (true) return InstructionConstants.LUSHR  ;}
      break;
    case LXOR:
      jj_consume_token(LXOR);
              {if (true) return InstructionConstants.LXOR  ;}
      break;
    case MONITORENTER:
      jj_consume_token(MONITORENTER);
                      {if (true) return InstructionConstants.MONITORENTER  ;}
      break;
    case MONITOREXIT:
      jj_consume_token(MONITOREXIT);
                     {if (true) return InstructionConstants.MONITOREXIT  ;}
      break;
    case MULTIANEWARRAY:
      jj_consume_token(MULTIANEWARRAY);
      s = classname();
      t1 = jj_consume_token(INTEGER_LITERAL);
            {
            int j = cpg.addClass(s);
            try
            {
                short k = Short.parseShort(t1.image);
                {if (true) return new MULTIANEWARRAY(j, k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid MULTIANEWARRAY argument: " + t1.image);}
            }
            }
      break;
    case NEW:
      jj_consume_token(NEW);
      s = classname();
            {
            int k = cpg.addClass(s);
            {if (true) return new NEW(k);}
            }
      break;
    case NEWARRAY:
      jj_consume_token(NEWARRAY);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                if (k < 4 || k > 10)
                    {if (true) throw new NumberFormatException();}
                {if (true) return new NEWARRAY( (byte) k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid NEWARRAY argument: " + t1.image);}
            }
      break;
    case NOP:
      jj_consume_token(NOP);
            {if (true) return InstructionConstants.NOP  ;}
      break;
    case POP:
      jj_consume_token(POP);
             {if (true) return InstructionConstants.POP  ;}
      break;
    case POP2:
      jj_consume_token(POP2);
              {if (true) return InstructionConstants.POP2  ;}
      break;
    case PUTFIELD:
      jj_consume_token(PUTFIELD);
      s = classname();
      t1 = jj_consume_token(IDENTIFIER);
      t2 = jj_consume_token(STRING_LITERAL);
            {
            String p = t2.image.substring(1, t2.image.length()-1);
            int k = cpg.addFieldref(s, t1.image, p);
            {if (true) return new PUTFIELD(k);}
            }
      break;
    case PUTSTATIC:
      jj_consume_token(PUTSTATIC);
      s = classname();
      t1 = jj_consume_token(IDENTIFIER);
      t2 = jj_consume_token(STRING_LITERAL);
            {
            String p = t2.image.substring(1, t2.image.length()-1);
            int k = cpg.addFieldref(s, t1.image, p);
            {if (true) return new PUTSTATIC(k);}
            }
      break;
    case RET:
      jj_consume_token(RET);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                int k = Integer.parseInt(t1.image);
                if (k < 0 || k > 255)
                    {if (true) throw new NumberFormatException();}
                {if (true) return new RET(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid RET argument: " + t1.image);}
            }
      break;
    case RETURN:
      jj_consume_token(RETURN);
                {if (true) return InstructionConstants.RETURN  ;}
      break;
    case SALOAD:
      jj_consume_token(SALOAD);
                {if (true) return InstructionConstants.SALOAD  ;}
      break;
    case SASTORE:
      jj_consume_token(SASTORE);
                 {if (true) return InstructionConstants.SASTORE  ;}
      break;
    case SIPUSH:
      jj_consume_token(SIPUSH);
      t1 = jj_consume_token(INTEGER_LITERAL);
            try
            {
                short k = Short.parseShort(t1.image);
                {if (true) return new SIPUSH(k);}
            }
            catch (NumberFormatException e)
            {
                {if (true) throw new ParseException("Invalid SIPUSH argument: " + t1.image);}
            }
      break;
    case SWAP:
      jj_consume_token(SWAP);
              {if (true) return InstructionConstants.SWAP  ;}
      break;
    case TABLESWITCH:
      jj_consume_token(TABLESWITCH);
      jj_consume_token(DEFAUL);
      t1 = jj_consume_token(IDENTIFIER);
                                v = new Vector();
                                v1 = new Vector();
                                v.add(t1.image);
      label_3:
      while (true) {
        jj_consume_token(CASE);
        t2 = jj_consume_token(INTEGER_LITERAL);
        t3 = jj_consume_token(IDENTIFIER);
                                v1.add(t2.image);
                                v.add(t3.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
      }
            {
            int[] match = new int[v1.size()];
            for (int i = 0; i < match.length; i++)
            {
                try {
                    match[i] = Integer.parseInt(((String) v1.elementAt(i)));
                }
                catch (NumberFormatException e)
                {
                    {if (true) throw new ParseException("Invalid case argument: " + v1.elementAt(i));}
                }
            }
            TABLESWITCH ls = new TABLESWITCH(match, new InstructionHandle[match.length], null);
            {if (true) return new FakeBranchInstruction(ls, v);}
            }
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public String classname() throws ParseException {
String s = null;
Token t1 = null;
    t1 = jj_consume_token(IDENTIFIER);
                        s = t1.image;
    label_4:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(DOT);
      t1 = jj_consume_token(IDENTIFIER);
                                             s += "." + t1.image;
    }
      {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public void directive() throws ParseException {
Token t = null, t1 = null;
int af;
String s;
    jj_consume_token(DOT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      jj_consume_token(LOCAL);
      t = jj_consume_token(INTEGER_LITERAL);
                                try
                                {
                                   int k = Integer.parseInt(t.image);
                                   meth.setMaxLocals(meth.getMaxLocals() + k);
                }
                catch (NumberFormatException e)
                {
                    {if (true) throw new ParseException("Invalid .local argument: " + t.image);}
                }
      break;
    case FIELD:
      jj_consume_token(FIELD);
      af = accessFlags();
      t1 = jj_consume_token(STRING_LITERAL);
      t = jj_consume_token(IDENTIFIER);
                            s = "()"+t1.image.substring(1, t1.image.length()-1);
                                        if ( clg.containsField(t.image) == null)
                                        {
                                    Field f = new FieldGen(af, Type.getReturnType(s),
                                                        t.image, cpg).getField();
                                                clg.addField(f);
                                        }
                                        else
                                                {if (true) throw new ParseException("Field "+ t.image + "already exists");}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public int accessFlags() throws ParseException {
int k = 0;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
        jj_consume_token(PRIVATE);
                            k += 1;
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
                           k += 2;
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
                             k += 3;
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
          {if (true) return k;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public ASMParseTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private int jj_gen;
  final private int[] jj_la1 = new int[11];
  final private int[] jj_la1_0 = {0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,};
  final private int[] jj_la1_1 = {0xffffffc0,0xffffffc0,0x8,0x0,0x0,0x0,0x20,0xffffffc0,0x0,0x7,0x7,};
  final private int[] jj_la1_2 = {0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,};
  final private int[] jj_la1_3 = {0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,};
  final private int[] jj_la1_4 = {0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,};
  final private int[] jj_la1_5 = {0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,};
  final private int[] jj_la1_6 = {0x21ff7fff,0x21ff7fff,0x20000000,0x1c000000,0x1c000000,0x1c000000,0x0,0x1ff7fff,0x0,0x0,0x0,};
  final private int[] jj_la1_7 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public ASMParse(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ASMParseTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ASMParse(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ASMParseTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ASMParse(ASMParseTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ASMParseTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration en = jj_expentries.elements(); en.hasMoreElements();) {
        int[] oldentry = (int[])(en.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[225];
    for (int i = 0; i < 225; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 11; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 225; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class FakeBranchInstruction extends BranchInstruction
{
/**
	 * Added to jdk1.5.0_04 compiler
	 */
	private static final long serialVersionUID = 3168191126907656820L;
BranchInstruction ri;
Vector v;

    FakeBranchInstruction(BranchInstruction ins, Vector x)
    {
        super(ins.getOpcode(), ins.getTarget());
        ri = ins;
        v = x;
    }

    public void accept(org.apache.bcel.generic.Visitor v)
    {
    }

    public String[] getTargets()
    {
        String[] t = new String[v.size()];
        for (int i = 0; i < t.length; i++)
            t[i] = (String) v.elementAt(i);
        return t;
    }

    public BranchInstruction getRealInstruction()
    {
        return ri;
    }
}
